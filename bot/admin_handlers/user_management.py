import logging
from telebot import types, apihelper
from typing import Optional, Dict, Any
from ..database import db
from ..menu import menu
from .. import combined_handler
from ..admin_formatters import fmt_admin_user_summary, fmt_user_payment_history
from ..utils import _safe_edit, escape_markdown, load_service_plans, save_service_plans

from ..config import LOYALTY_REWARDS, REFERRAL_REWARD_GB, REFERRAL_REWARD_DAYS

logger = logging.getLogger(__name__)
bot, admin_conversations = None, None


def initialize_user_management_handlers(b, conv_dict):
    global bot, admin_conversations
    bot = b
    admin_conversations = conv_dict

def handle_show_user_summary(call, params):
    """
    CORRECTED: Parses parameters correctly to fetch user info using the full identifier.
    The identifier is now correctly retrieved from params[1].
    """
    # <<<<<<< START OF FIX: Correctly parse params from the callback >>>>>>>>>
    # The callback is formatted as "admin:us:{panel_short}:{identifier}:{context}"
    # So, params[0] is panel_short, params[1] is the identifier.
    identifier = params[1] 
    back_target = params[2] if len(params) > 2 else 'management_menu'
    # <<<<<<< END OF FIX >>>>>>>>>
    
    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        _safe_edit(call.from_user.id, call.message.message_id, escape_markdown("ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±."),
                   reply_markup=menu.admin_search_menu()) 
        return

    db_user = None
    if info.get('uuid'):
        user_telegram_id = db.get_user_id_by_uuid(info['uuid'])
        if user_telegram_id:
            db_user = db.user(user_telegram_id)

    # This function now generates the new desired format
    text = fmt_admin_user_summary(info, db_user)
    
    back_callback = f"admin:{back_target}" if back_target in ['search_menu', 'management_menu'] else "admin:search_menu"
    
    panel_type = 'hiddify' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'marzban'
    kb = menu.admin_user_interactive_management(identifier, info.get('is_active', False), panel_type, back_callback=back_callback)
    
    _safe_edit(call.from_user.id, call.message.message_id, text, reply_markup=kb)


def handle_edit_user_menu(call, params):
    """
    ŸÖŸÜŸà€å ÿßÿµŸÑ€å Ÿà€åÿ±ÿß€åÿ¥ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ÿß ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å "ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≠ÿ¨ŸÖ" Ÿà "ÿßŸÅÿ≤ŸàÿØŸÜ ÿ±Ÿàÿ≤" ŸÜŸÖÿß€åÿ¥ ŸÖ€å‚ÄåÿØŸáÿØ.
    """
    identifier = params[0]
    # ÿ™ÿ¥ÿÆ€åÿµ ÿß€åŸÜ⁄©Ÿá ÿ¢€åÿß ÿßÿ≤ ŸÖŸÜŸà€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿ¢ŸÖÿØŸá‚Äåÿß€åŸÖ €åÿß ŸÜŸá
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    context_suffix = f":{context}" if context else ""

    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    breakdown = info.get('breakdown', {})
    on_hiddify = any(p.get('type') == 'hiddify' for p in breakdown.values())
    on_marzban = any(p.get('type') == 'marzban' for p in breakdown.values())

    # ÿß⁄Øÿ± ⁄©ÿßÿ±ÿ®ÿ± ŸÅŸÇÿ∑ ÿØÿ± €å⁄© ŸÜŸàÿπ ŸæŸÜŸÑ ÿ≠ÿ∂Ÿàÿ± ÿØÿßÿ¥ÿ™ÿå ŸÖÿ≥ÿ™ŸÇ€åŸÖÿßŸã ÿ®Ÿá ŸÖÿ±ÿ≠ŸÑŸá Ÿæÿ±ÿ≥€åÿØŸÜ ŸÖŸÇÿØÿßÿ± ŸÖ€å‚Äåÿ±Ÿà€åŸÖ
    single_panel_type = None
    if on_hiddify and not on_marzban:
        single_panel_type = 'hiddify'
    elif on_marzban and not on_hiddify:
        single_panel_type = 'marzban'

    prompt = "üîß ŸÑÿ∑ŸÅÿßŸã ŸÜŸàÿπ Ÿà€åÿ±ÿß€åÿ¥ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
    kb = types.InlineKeyboardMarkup(row_width=2)
    
    # ÿß⁄Øÿ± ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± Ÿáÿ± ÿØŸà ŸæŸÜŸÑ ÿ®ŸàÿØÿå ÿßÿ®ÿ™ÿØÿß ÿßÿ≤ ÿßŸà ŸÖ€å‚ÄåŸæÿ±ÿ≥€åŸÖ ⁄©Ÿá Ÿà€åÿ±ÿß€åÿ¥ ÿ®ÿ±ÿß€å ⁄©ÿØÿßŸÖ ŸæŸÜŸÑ ÿßÿ≥ÿ™
    if single_panel_type:
        btn_add_gb = types.InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≠ÿ¨ŸÖ", callback_data=f"admin:ae:agb:{single_panel_type}:{identifier}{context_suffix}")
        btn_add_days = types.InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿ±Ÿàÿ≤", callback_data=f"admin:ae:ady:{single_panel_type}:{identifier}{context_suffix}")
    else:
        # callback 'ep' (edit panel) ÿ®ÿ±ÿß€å ŸÜŸÖÿß€åÿ¥ ŸÖŸÜŸà€å ÿßŸÜÿ™ÿÆÿßÿ® ŸæŸÜŸÑ ÿßÿ≥ÿ™
        btn_add_gb = types.InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≠ÿ¨ŸÖ", callback_data=f"admin:ep:agb:{identifier}{context_suffix}")
        btn_add_days = types.InlineKeyboardButton("‚ûï ÿßŸÅÿ≤ŸàÿØŸÜ ÿ±Ÿàÿ≤", callback_data=f"admin:ep:ady:{identifier}{context_suffix}")

    panel_short_for_back = 'h' if on_hiddify else 'm'
    btn_back = types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=f"admin:us:{panel_short_for_back}:{identifier}{context_suffix}")
    
    kb.add(btn_add_gb, btn_add_days)
    kb.add(btn_back)
    
    _safe_edit(call.from_user.id, call.message.message_id, escape_markdown(prompt), reply_markup=kb)


def handle_select_panel_for_edit(call, params):
    """
    ÿß⁄Øÿ± ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± Ÿáÿ± ÿØŸà ŸæŸÜŸÑ ÿ®ÿßÿ¥ÿØÿå ÿß€åŸÜ ŸÖŸÜŸà ÿ®ÿ±ÿß€å ÿßŸÜÿ™ÿÆÿßÿ® ŸæŸÜŸÑ ŸÖŸÇÿµÿØ (ÿ¢ŸÑŸÖÿßŸÜ €åÿß ŸÅÿ±ÿßŸÜÿ≥Ÿá) ŸÜŸÖÿß€åÿ¥ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ.
    """
    edit_type, identifier = params[0], params[1]
    context = "search" if len(params) > 2 and params[2] == 'search' else None
    context_suffix = f":{context}" if context else ""

    edit_type_map = {"agb": "ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≠ÿ¨ŸÖ", "ady": "ÿßŸÅÿ≤ŸàÿØŸÜ ÿ±Ÿàÿ≤"}
    edit_type_name = edit_type_map.get(edit_type, "Ÿà€åÿ±ÿß€åÿ¥")

    prompt = f"‚öôÔ∏è ŸÑÿ∑ŸÅÿßŸã ŸæŸÜŸÑ€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ¬´{edit_type_name}¬ª ÿ®Ÿá ÿ¢ŸÜ ÿßÿ∂ÿßŸÅŸá ÿ¥ŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
    
    kb = types.InlineKeyboardMarkup(row_width=2)
    # ŸÜÿßŸÖ ŸæŸÜŸÑ‚ÄåŸáÿß ÿ®Ÿá ÿ¨ÿß€å hiddify/marzban ÿ®ÿ±ÿß€å ÿÆŸàÿßŸÜÿß€å€å ÿ®Ÿáÿ™ÿ± ÿ®Ÿá ⁄©ÿßÿ± ÿ±ŸÅÿ™Ÿá ÿßÿ≥ÿ™
    btn_h = types.InlineKeyboardButton("ÿ¢ŸÑŸÖÿßŸÜ üá©üá™", callback_data=f"admin:ae:{edit_type}:hiddify:{identifier}{context_suffix}")
    btn_m = types.InlineKeyboardButton("ŸÅÿ±ÿßŸÜÿ≥Ÿá üá´üá∑", callback_data=f"admin:ae:{edit_type}:marzban:{identifier}{context_suffix}")
    
    kb.add(btn_h, btn_m)
    kb.add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=f"admin:edt:{identifier}{context_suffix}"))
    
    _safe_edit(call.from_user.id, call.message.message_id, escape_markdown(prompt), reply_markup=kb)


def handle_ask_edit_value(call, params):
    """
    ÿßÿ≤ ÿßÿØŸÖ€åŸÜ ŸÖ€å‚ÄåŸæÿ±ÿ≥ÿØ ⁄©Ÿá ⁄ÜŸá ŸÖŸÇÿØÿßÿ± ÿ≠ÿ¨ŸÖ €åÿß ÿ±Ÿàÿ≤ ŸÖ€å‚ÄåÿÆŸàÿßŸáÿØ ÿßÿ∂ÿßŸÅŸá ⁄©ŸÜÿØ.
    """
    edit_type, panel_type, identifier = params[0], params[1], params[2]
    context = "search" if len(params) > 3 and params[3] == "search" else None
    
    prompt_map = {
        "agb": "ŸÖŸÇÿØÿßÿ± ÿ≠ÿ¨ŸÖ ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ŸàÿØŸÜ (ÿ®Ÿá GB) ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
        "ady": "ÿ™ÿπÿØÿßÿØ ÿ±Ÿàÿ≤ ÿ®ÿ±ÿß€å ÿßŸÅÿ≤ŸàÿØŸÜ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:"
    }
    prompt = prompt_map.get(edit_type, "ŸÖŸÇÿØÿßÿ± ÿ¨ÿØ€åÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")
    
    uid, msg_id = call.from_user.id, call.message.message_id
    back_cb = f"admin:edt:{identifier}{ (':' + context) if context else '' }"
    
    # ÿßÿ∑ŸÑÿßÿπÿßÿ™ ŸÑÿßÿ≤ŸÖ ÿ®ÿ±ÿß€å ŸÖÿ±ÿ≠ŸÑŸá ÿ®ÿπÿØ ÿØÿ± ÿ≠ÿßŸÅÿ∏Ÿá ŸÖŸàŸÇÿ™ ÿ∞ÿÆ€åÿ±Ÿá ŸÖ€å‚Äåÿ¥ŸàÿØ
    admin_conversations[uid] = {
        'edit_type': edit_type, 
        'panel_type': panel_type, 
        'identifier': identifier, 
        'msg_id': msg_id,
        'context': context 
    }
    _safe_edit(uid, msg_id, escape_markdown(prompt), reply_markup=menu.admin_cancel_action(back_callback=back_cb), parse_mode=None)
    bot.register_next_step_handler_by_chat_id(uid, apply_user_edit)


def apply_user_edit(msg: types.Message):
    """
    ŸÖŸÇÿØÿßÿ± Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿßÿØŸÖ€åŸÜ ÿ±ÿß ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿ±ÿØŸá Ÿà ÿ®ÿß API ŸæŸÜŸÑÿå ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß Ÿà€åÿ±ÿß€åÿ¥ ŸÖ€å‚Äå⁄©ŸÜÿØ.
    """
    uid, text = msg.from_user.id, msg.text.strip()
    bot.delete_message(uid, msg.message_id) 
    if uid not in admin_conversations: return

    convo = admin_conversations.pop(uid, {})
    identifier = convo.get('identifier')
    edit_type = convo.get('edit_type')
    panel_type = convo.get('panel_type') # ŸÜÿßŸÖ ŸæŸÜŸÑ (hiddify €åÿß marzban)
    msg_id = convo.get('msg_id')
    context = convo.get('context')

    if not all([identifier, edit_type, panel_type, msg_id]): return

    try:
        value = float(text)
        add_gb = value if edit_type == "agb" else 0
        add_days = int(value) if edit_type == "ady" else 0
        
        # ÿß€åŸÜ ÿ™ÿßÿ®ÿπ ÿ®Ÿá ÿµŸàÿ±ÿ™ ŸáŸàÿ¥ŸÖŸÜÿØ ÿπŸÖŸÑ ⁄©ÿ±ÿØŸá Ÿà ŸÅŸÇÿ∑ ŸæŸÜŸÑ ŸÖÿ¥ÿÆÿµ ÿ¥ÿØŸá ÿ±ÿß Ÿà€åÿ±ÿß€åÿ¥ ŸÖ€å‚Äå⁄©ŸÜÿØ
        success = combined_handler.modify_user_on_all_panels(
            identifier=identifier, add_gb=add_gb, add_days=add_days, target_panel_type=panel_type
        )

        if success:
            new_info = combined_handler.get_combined_user_info(identifier)
            # (ÿ®ÿÆÿ¥ ÿßÿ±ÿ≥ÿßŸÑ ŸÜŸàÿ™€åŸÅ€å⁄©€åÿ¥ŸÜ ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ± Ÿà ŸÜŸÖÿß€åÿ¥ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ¨ÿØ€åÿØ)
            text_to_show = fmt_admin_user_summary(new_info) + "\n\n*‚úÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ Ÿà€åÿ±ÿß€åÿ¥ ÿ¥ÿØ\\.*"
            back_callback = "admin:search_menu" if context == "search" else None
            kb = menu.admin_user_interactive_management(identifier, new_info['is_active'], panel_type, back_callback=back_callback)
            _safe_edit(uid, msg_id, text_to_show, reply_markup=kb)
        else:
            raise Exception("API call failed")

    except Exception as e:
        logger.error(f"Failed to apply user edit for {identifier}: {e}")
        _safe_edit(uid, msg_id, escape_markdown("‚ùå ÿÆÿ∑ÿß ÿØÿ± Ÿà€åÿ±ÿß€åÿ¥ ⁄©ÿßÿ±ÿ®ÿ±."), reply_markup=menu.admin_panel())


def handle_toggle_status(call, params):
    """
    Handles the initial "Change Status" button press.
    If the user is on multiple panels, it shows a selection menu.
    """
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None

    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    breakdown = info.get('breakdown', {})
    on_hiddify = any(p.get('type') == 'hiddify' for p in breakdown.values())
    on_marzban = any(p.get('type') == 'marzban' for p in breakdown.values())

    # If user is only on one type of panel, toggle it directly
    if on_hiddify and not on_marzban:
        action_params = ['hiddify', identifier]
        if context: action_params.append(context)
        handle_toggle_status_action(call, action_params)
        return
    elif on_marzban and not on_hiddify:
        action_params = ['marzban', identifier]
        if context: action_params.append(context)
        handle_toggle_status_action(call, action_params)
        return
    
    # If user is on both, show a selection menu
    prompt = "‚öôÔ∏è *Ÿàÿ∂ÿπ€åÿ™ ⁄©ÿØÿßŸÖ ŸæŸÜŸÑ ÿ™ÿ∫€å€åÿ± ⁄©ŸÜÿØÿü*"
    # We can reuse the reset_usage_selection_menu for this purpose
    kb = menu.admin_reset_usage_selection_menu(identifier, base_callback="tglA", context=context)
    _safe_edit(call.from_user.id, call.message.message_id, prompt, reply_markup=kb)


def handle_toggle_status_action(call, params):
    """
    Executes the status change on the selected panel(s) after admin makes a choice.
    """
    panel_to_toggle, identifier = params[0], params[1]
    context = "search" if len(params) > 2 and params[2] == 'search' else None

    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    success = True
    
    # Get all active panels to find the correct handler
    active_panels = {p['name']: p for p in db.get_active_panels()}

    for panel_name, panel_details in info.get('breakdown', {}).items():
        panel_type = panel_details.get('type')
        panel_data = panel_details.get('data', {})
        
        # Check if this panel should be toggled
        if panel_type == panel_to_toggle or panel_to_toggle == 'both':
            panel_config = active_panels.get(panel_name)
            if not panel_config: continue

            handler = combined_handler._get_handler_for_panel(panel_config)
            if not handler: continue
            
            current_status = panel_data.get('is_active', False)
            new_status = not current_status
            
            if panel_type == 'hiddify' and info.get('uuid'):
                if not handler.modify_user(info['uuid'], data={'enable': new_status}):
                    success = False
            
            elif panel_type == 'marzban' and panel_data.get('username'):
                marzban_status = 'active' if new_status else 'disabled'
                if not handler.modify_user(panel_data['username'], data={'status': marzban_status}):
                    success = False
    
    if success:
        bot.answer_callback_query(call.id, "‚úÖ Ÿàÿ∂ÿπ€åÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ.")
        # Refresh and display updated user info
        new_info = combined_handler.get_combined_user_info(identifier)
        if new_info:
            back_callback = "admin:search_menu" if context == "search" else "admin:management_menu"
            db_user = None
            if new_info.get('uuid'):
                user_telegram_id = db.get_user_id_by_uuid(new_info['uuid'])
                if user_telegram_id: db_user = db.user(user_telegram_id)
            
            text = fmt_admin_user_summary(new_info, db_user)
            panel_type_for_menu = 'hiddify' if any(p.get('type') == 'hiddify' for p in new_info.get('breakdown', {}).values()) else 'marzban'
            kb = menu.admin_user_interactive_management(identifier, new_info.get('is_active', False), panel_type_for_menu, back_callback=back_callback)
            _safe_edit(call.from_user.id, call.message.message_id, text, reply_markup=kb)
    else:
        bot.answer_callback_query(call.id, "‚ùå ÿπŸÖŸÑ€åÿßÿ™ ÿØÿ± €å⁄© €åÿß ⁄ÜŸÜÿØ ŸæŸÜŸÑ ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.", show_alert=True)


def handle_reset_birthday(call, params):
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    context_suffix = f":{context}" if context else ""

    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ÿÆÿ∑ÿß: UUID ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ±ÿß€å €åÿßŸÅÿ™ŸÜ ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™.", show_alert=True)
        return

    user_id_to_reset = db.get_user_id_by_uuid(info['uuid'])
    if not user_id_to_reset:
        panel_for_back = 'h' if bool(info.get('breakdown', {}).get('hiddify')) else 'm'
        back_cb = f"admin:us:{panel_for_back}:{identifier}{context_suffix}"
        kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb))
        _safe_edit(call.from_user.id, call.message.message_id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", reply_markup=kb)
        return

    db.reset_user_birthday(user_id_to_reset)
    new_info = combined_handler.get_combined_user_info(identifier)
    
    panel_for_menu = 'hiddify' if bool(new_info.get('breakdown', {}).get('hiddify')) else 'marzban'
    text_to_show = fmt_admin_user_summary(new_info) + "\n\n*‚úÖ ÿ™ÿßÿ±€åÿÆ ÿ™ŸàŸÑÿØ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ±€åÿ≥ÿ™ ÿ¥ÿØ\\.*"
    back_callback = "admin:search_menu" if context == "search" else None
    
    kb = menu.admin_user_interactive_management(identifier, new_info['is_active'], panel_for_menu, back_callback=back_callback)
    _safe_edit(call.from_user.id, call.message.message_id, text_to_show, reply_markup=kb)


def handle_reset_usage_menu(call, params):
    identifier = params[0]
    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    _safe_edit(call.from_user.id, call.message.message_id, escape_markdown("‚öôÔ∏è *ŸÖÿµÿ±ŸÅ ⁄©ÿØÿßŸÖ ŸæŸÜŸÑ ÿµŸÅÿ± ÿ¥ŸàÿØÿü*"),
               reply_markup=menu.admin_reset_usage_selection_menu(identifier, base_callback="rsa"))


def handle_reset_usage_action(call, params):
    panel_to_reset, identifier = params[0], params[1]

    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    h_success, m_success = True, True
    uuid_id_in_db = db.get_uuid_id_by_uuid(info.get('uuid', ''))

    if panel_to_reset in ['hiddify', 'both'] and 'hiddify' in info.get('breakdown', {}):
        h_success = combined_handler.hiddify_handler.reset_user_usage(info['uuid'])

    if panel_to_reset in ['marzban', 'both'] and 'marzban' in info.get('breakdown', {}):
        m_success = combined_handler.marzban_handler.reset_user_usage(info['name'])

    if h_success and m_success:
        if uuid_id_in_db:
            db.delete_user_snapshots(uuid_id_in_db)
            db.add_usage_snapshot(uuid_id_in_db, 0.0, 0.0)
            db.delete_user_agents_by_uuid_id(uuid_id_in_db)

        new_info = combined_handler.get_combined_user_info(identifier)
        if new_info:
            user_telegram_id = db.get_user_id_by_uuid(new_info.get('uuid', ''))
            panel_name_map = {'hiddify': 'ÿ¢ŸÑŸÖÿßŸÜ üá©üá™', 'marzban': 'ŸÅÿ±ÿßŸÜÿ≥Ÿá üá´üá∑', 'both': 'Ÿáÿ± ÿØŸà ŸæŸÜŸÑ'}
            panel_name = panel_name_map.get(panel_to_reset, 'ÿß⁄©ÿßŸÜÿ™ ÿ¥ŸÖÿß')
            notification_text = f"üîÑ ŸÖÿµÿ±ŸÅ ÿØ€åÿ™ÿß€å ÿß⁄©ÿßŸÜÿ™ ÿ¥ŸÖÿß ÿ®ÿ±ÿß€å *{escape_markdown(panel_name)}* ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿµŸÅÿ± ÿ¥ÿØ\\."
            _notify_user(user_telegram_id, notification_text)

            text_to_show = fmt_admin_user_summary(new_info) + "\n\n*‚úÖ ŸÖÿµÿ±ŸÅ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿµŸÅÿ± ÿ¥ÿØ\\.*"
            original_panel = 'hiddify' if bool(new_info.get('breakdown', {}).get('hiddify')) else 'marzban'
            kb = menu.admin_user_interactive_management(identifier, new_info['is_active'], original_panel)
            _safe_edit(call.from_user.id, call.message.message_id, text_to_show, reply_markup=kb)
    else:
        bot.answer_callback_query(call.id, "‚ùå ÿπŸÖŸÑ€åÿßÿ™ ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ.", show_alert=True)


def handle_delete_user_confirm(call, params):
    identifier = params[0]
    info = combined_handler.get_combined_user_info(identifier)
    if not info:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return
    panel = 'hiddify' if bool(info.get('breakdown', {}).get('hiddify')) else 'marzban'

    text = f"‚ö†Ô∏è *ÿ¢€åÿß ÿßÿ≤ ÿ≠ÿ∞ŸÅ ⁄©ÿßŸÖŸÑ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá ÿ≤€åÿ± ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿØÿßÿ±€åÿØÿü*\n`{escape_markdown(identifier)}`"
    kb = menu.confirm_delete(identifier, panel)
    _safe_edit(call.from_user.id, call.message.message_id, text, reply_markup=kb)


def handle_delete_user_action(call, params):
    action, panel, identifier = params[0], params[1], params[2]

    uid, msg_id = call.from_user.id, call.message.message_id
    if action == "cancel":
        info = combined_handler.get_combined_user_info(identifier)
        if info:
            current_panel = 'hiddify' if bool(info.get('breakdown', {}).get('hiddify')) else 'marzban'
            kb = menu.admin_user_interactive_management(identifier, info['is_active'], current_panel)
            _safe_edit(uid, msg_id, fmt_admin_user_summary(info), reply_markup=kb)
        else:
            _safe_edit(uid, msg_id, "ÿπŸÖŸÑ€åÿßÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ Ÿà ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", reply_markup=menu.admin_search_menu())
        return

    if action == "confirm":
        _safe_edit(uid, msg_id, "‚è≥ ÿØÿ± ÿ≠ÿßŸÑ ÿ≠ÿ∞ŸÅ ⁄©ÿßŸÖŸÑ ⁄©ÿßÿ±ÿ®ÿ±...")
        success = combined_handler.delete_user_from_all_panels(identifier)
        if success:
            _safe_edit(uid, msg_id, "‚úÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßÿ≤ ÿ™ŸÖÿßŸÖ ŸæŸÜŸÑ‚ÄåŸáÿß Ÿà ÿ±ÿ®ÿßÿ™ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.",
                       reply_markup=menu.admin_search_menu())
        else:
            _safe_edit(uid, msg_id, "‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ≠ÿ∞ŸÅ ⁄©ÿßÿ±ÿ®ÿ±.", reply_markup=menu.admin_search_menu())


def handle_global_search_convo(call, params):
    uid, msg_id = call.from_user.id, call.message.message_id
    prompt = "ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ €åÿß UUID ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ®ÿ±ÿß€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± Ÿáÿ± ÿØŸà ŸæŸÜŸÑ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:"
    admin_conversations[uid] = {'msg_id': msg_id}
    _safe_edit(uid, msg_id, escape_markdown(prompt), reply_markup=menu.admin_cancel_action("admin:search_menu"))
    bot.register_next_step_handler_by_chat_id(uid, _handle_global_search_response)


def _handle_global_search_response(message: types.Message):
    """
    Handles the admin's response to the global search prompt.
    Searches for users and displays results as a list of buttons if multiple are found.
    """
    uid, query = message.from_user.id, message.text.strip()
    try:
        bot.delete_message(uid, message.message_id)
    except apihelper.ApiTelegramException as e:
        if "message to delete not found" in e.description:
            logger.warning(f"Message {message.message_id} already deleted, proceeding with search.")
        else:
            raise e
    convo_data = admin_conversations.pop(uid, None)
    if not convo_data: return

    original_msg_id = convo_data['msg_id']
    _safe_edit(uid, original_msg_id, "ÿØÿ± ÿ≠ÿßŸÑ ÿ¨ÿ≥ÿ™ÿ¨Ÿà...", parse_mode=None)

    try:
        results = combined_handler.search_user(query)

        if not results:
            prompt = f"‚ùå ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ŸÖÿ¥ÿÆÿµÿßÿ™ `{escape_markdown(query)}` €åÿßŸÅÿ™ ŸÜÿ¥ÿØ\\."
            kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿ¨ÿ≥ÿ™ÿ¨Ÿà", callback_data="admin:search_menu"))
            _safe_edit(uid, original_msg_id, prompt, reply_markup=kb)
            # Re-register for another search attempt
            admin_conversations[uid] = {'msg_id': original_msg_id}
            bot.register_next_step_handler_by_chat_id(uid, _handle_global_search_response)
            return

        if len(results) == 1:
            # If only one user is found, show summary directly
            user = results[0]
            identifier = user.get('uuid') or user.get('name')
            # (The logic for showing a single user remains the same)
            db_user = None
            if user.get('uuid'):
                user_telegram_id = db.get_user_id_by_uuid(user['uuid'])
                if user_telegram_id:
                    db_user = db.user(user_telegram_id)
            text = fmt_admin_user_summary(user, db_user)
            panel_type = 'hiddify' if any(p.get('type') == 'hiddify' for p in user.get('breakdown', {}).values()) else 'marzban'
            kb = menu.admin_user_interactive_management(identifier, user.get('is_active', False), panel_type, back_callback="admin:search_menu")
            _safe_edit(uid, original_msg_id, text, reply_markup=kb)
        else:
            # If multiple users are found, show a selection list
            kb = types.InlineKeyboardMarkup(row_width=1)
            prompt = "⁄ÜŸÜÿØ€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
            
            for user in results:
                identifier_for_callback = user.get('uuid') or user.get('name')
                status_emoji = "‚úÖ" if user.get('is_active') else "‚ùå"
                button_text = f"{status_emoji} {user.get('name', '⁄©ÿßÿ±ÿ®ÿ± ŸÜÿßÿ¥ŸÜÿßÿ≥')}"
                
                # We need a panel hint for the callback, 'h' or 'm'
                panel_short = 'h' if any(p.get('type') == 'hiddify' for p in user.get('breakdown', {}).values()) else 'm'
                
                callback_data = f"admin:us:{panel_short}:{identifier_for_callback}:search"
                kb.add(types.InlineKeyboardButton(button_text, callback_data=callback_data))

            kb.add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà", callback_data="admin:search_menu"))
            _safe_edit(uid, original_msg_id, prompt, reply_markup=kb, parse_mode=None)

    except Exception as e:
        logger.error(f"Global search failed for query '{query}': {e}", exc_info=True)
        _safe_edit(uid, original_msg_id, "‚ùå ÿÆÿ∑ÿß€å€å ÿØÿ± ŸáŸÜ⁄ØÿßŸÖ ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿ±ÿÆ ÿØÿßÿØ.", reply_markup=menu.admin_search_menu())



def handle_log_payment(call, params):
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    context_suffix = f":{context}" if context else ""
    
    uid, msg_id = call.from_user.id, call.message.message_id

    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß UUID ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    uuid_id = db.get_uuid_id_by_uuid(info['uuid'])
    if not uuid_id:
        panel_for_back = 'h' if bool(info.get('breakdown', {}).get('hiddify')) else 'm'
        back_cb = f"admin:us:{panel_for_back}:{identifier}{context_suffix}"
        kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb))
        _safe_edit(uid, msg_id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", reply_markup=kb)
        return

    previous_payments_count = len(db.get_user_payment_history(uuid_id))
    
    if db.add_payment_record(uuid_id):
        user_telegram_id = db.get_user_id_by_uuid(info['uuid'])
        user_name = escape_markdown(info.get('name', ''))
        
        action_text = "ÿÆÿ±€åÿØÿßÿ±€å ÿ¥ÿØ" if previous_payments_count == 0 else "ÿ™ŸÖÿØ€åÿØ ÿ¥ÿØ"
        
        notification_text = (
            f"ÿ®ÿß ÿ™ÿ¥⁄©ÿ± ÿßÿ≤ ÿ¥ŸÖÿß üôè\n\n"
            f"‚úÖ Ÿæÿ±ÿØÿßÿÆÿ™ ÿ¥ŸÖÿß ÿ®ÿ±ÿß€å ÿß⁄©ÿßŸÜÿ™ *{user_name}* ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ´ÿ®ÿ™ Ÿà ÿ≥ÿ±Ÿà€åÿ≥ ÿ¥ŸÖÿß *{action_text}*\\."
        )
        _notify_user(user_telegram_id, notification_text)
        if previous_payments_count == 0:
            _check_and_apply_referral_reward(user_telegram_id)


        panel_for_menu = 'hiddify' if bool(info.get('breakdown', {}).get('hiddify')) else 'marzban'
        back_callback = "admin:search_menu" if context == "search" else None
        text_to_show = fmt_admin_user_summary(info) + f"\n\n*‚úÖ Ÿæÿ±ÿØÿßÿÆÿ™ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ´ÿ®ÿ™ ÿ¥ÿØ\\.*"
        
        kb = menu.admin_user_interactive_management(identifier, info['is_active'], panel_for_menu,
                                                    back_callback=back_callback)
        _safe_edit(uid, msg_id, text_to_show, reply_markup=kb)
    else:
        bot.answer_callback_query(call.id, "‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿ´ÿ®ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™.", show_alert=True)


def handle_payment_history(call, params):
    identifier = params[0]
    page = int(params[1])
    context = "search" if len(params) > 2 and params[2] == 'search' else None
    context_suffix = ":search" if context else ""
    
    uid, msg_id = call.from_user.id, call.message.message_id

    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß UUID ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    # --- ÿ®ÿÆÿ¥ ÿßÿµŸÑ€å ÿßÿµŸÑÿßÿ≠ ÿ¥ÿØŸá ---
    # ÿßÿ≤ €å⁄© ÿ™ÿßÿ®ÿπ ÿ¨ÿßŸÖÿπ‚Äåÿ™ÿ± ÿ®ÿ±ÿß€å ⁄Øÿ±ŸÅÿ™ŸÜ ÿßÿ∑ŸÑÿßÿπÿßÿ™ Ÿæÿ±ÿØÿßÿÆÿ™ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    all_payments = db.get_all_payments_with_user_info()
    # ŸÑ€åÿ≥ÿ™ Ÿæÿ±ÿØÿßÿÆÿ™‚ÄåŸáÿß ÿ±ÿß ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å UUID ⁄©ÿßÿ±ÿ®ÿ± ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ŸÅ€åŸÑÿ™ÿ± ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    user_payments = [p for p in all_payments if p.get('uuid') == info['uuid']]
    
    user_name_raw = info.get('name', '⁄©ÿßÿ±ÿ®ÿ± ŸÜÿßÿ¥ŸÜÿßÿ≥')
    # ŸÑ€åÿ≥ÿ™ ŸÅ€åŸÑÿ™ÿ± ÿ¥ÿØŸá ÿ±ÿß ÿ®Ÿá ÿ™ÿßÿ®ÿπ ŸÇÿßŸÑÿ®‚Äåÿ®ŸÜÿØ€å ÿßÿ±ÿ≥ÿßŸÑ ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    text = fmt_user_payment_history(user_payments, user_name_raw, page)
    # --- Ÿæÿß€åÿßŸÜ ÿ®ÿÆÿ¥ ÿßÿµŸÑÿßÿ≠ ÿ¥ÿØŸá ---

    panel_short = 'h' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'm'
    base_cb = f"admin:phist:{identifier}"
    back_cb_pagination = f"admin:us:{panel_short}:{identifier}{context_suffix}"
    
    kb = menu.create_pagination_menu(base_cb, page, len(user_payments), back_cb_pagination, context=context)
    _safe_edit(uid, msg_id, text, reply_markup=kb)


def handle_ask_for_note(call, params):
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    panel_short = params[2] if len(params) > 2 else 'h'
    panel = 'marzban' if panel_short == 'm' else 'hiddify'
    context_suffix = f":{context}" if context else ""
    
    uid, msg_id = call.from_user.id, call.message.message_id

    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß UUID ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    user_telegram_id = db.get_user_id_by_uuid(info['uuid'])
    if not user_telegram_id:
        panel_for_back = 'h' if bool(info.get('breakdown', {}).get('hiddify')) else 'm'
        back_cb = f"admin:us:{panel_for_back}:{identifier}{context_suffix}"
        kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_cb))
        _safe_edit(uid, msg_id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", reply_markup=kb)
        return

    db_user = db.user(user_telegram_id)
    current_note = db_user.get('admin_note') if db_user else None

    prompt = "ŸÑÿ∑ŸÅÿßŸã €åÿßÿØÿØÿßÿ¥ÿ™ ÿ¨ÿØ€åÿØ ÿ±ÿß ÿ®ÿ±ÿß€å ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ\\.\n\n"
    if current_note:
        prompt += f"*€åÿßÿØÿØÿßÿ¥ÿ™ ŸÅÿπŸÑ€å:*\n`{escape_markdown(current_note)}`\n\n"
    prompt += "ÿ®ÿ±ÿß€å ÿ≠ÿ∞ŸÅ €åÿßÿØÿØÿßÿ¥ÿ™ ŸÅÿπŸÑ€åÿå ⁄©ŸÑŸÖŸá `ÿ≠ÿ∞ŸÅ` ÿ±ÿß ÿßÿ±ÿ≥ÿßŸÑ ⁄©ŸÜ€åÿØ\\."

    admin_conversations[uid] = {
        'action_type': 'add_note',
        'identifier': identifier,
        'panel': panel,
        'user_telegram_id': user_telegram_id,
        'msg_id': msg_id,
        'context': context
    }
    
    back_cb = f"admin:us:{panel_short}:{identifier}{context_suffix}"
    _safe_edit(uid, msg_id, prompt, reply_markup=menu.admin_cancel_action(back_callback=back_cb))
    bot.register_next_step_handler_by_chat_id(uid, _save_user_note)


def _save_user_note(message: types.Message):
    uid, text = message.from_user.id, message.text.strip()
    bot.delete_message(uid, message.message_id)

    if uid not in admin_conversations: return

    convo = admin_conversations.pop(uid, {})
    if convo.get('action_type') != 'add_note': return

    msg_id = convo['msg_id']
    user_telegram_id = convo['user_telegram_id']
    identifier = convo['identifier']
    panel = convo['panel']
    context = convo.get('context')

    note_to_save = text
    if text.lower() in ['ÿ≠ÿ∞ŸÅ', 'delete', 'remove', 'del']:
        note_to_save = None

    db.update_user_note(user_telegram_id, note_to_save)

    info = combined_handler.get_combined_user_info(identifier)
    if info:
        db_user = db.user(user_telegram_id)
        text_to_show = fmt_admin_user_summary(info, db_user)
        
        back_callback = "admin:search_menu" if context == "search" else None
        kb = menu.admin_user_interactive_management(
            identifier, 
            info.get('is_active', False), 
            panel,
            back_callback=back_callback
        )
        _safe_edit(uid, msg_id, text_to_show, reply_markup=kb)


def _notify_user(user_id: Optional[int], message: str):
    if not user_id:
        return
    try:
        bot.send_message(user_id, message, parse_mode="MarkdownV2")
        logger.info(f"Sent notification to user {user_id}")
    except Exception as e:
        logger.warning(f"Failed to send notification to user {user_id}: {e}")


def handle_search_by_telegram_id_convo(call, params):
    uid, msg_id = call.from_user.id, call.message.message_id
    prompt = escape_markdown("ŸÑÿ∑ŸÅÿßŸã ÿ¥ŸÜÿßÿ≥Ÿá ÿπÿØÿØ€å (ID) ⁄©ÿßÿ±ÿ®ÿ± ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")

    admin_conversations[uid] = {'action_type': 'search_by_tid', 'msg_id': msg_id}

    _safe_edit(uid, msg_id, prompt, reply_markup=menu.admin_cancel_action("admin:search_menu"))
    bot.register_next_step_handler_by_chat_id(uid, _find_user_by_telegram_id)


def _find_user_by_telegram_id(message: types.Message):
    admin_id, text = message.from_user.id, message.text.strip()
    bot.delete_message(admin_id, message.message_id)

    if admin_id not in admin_conversations: return

    # <<<<<<< FIX START >>>>>>>>>
    # Don't pop the conversation yet, so we can check/set a flag.
    convo = admin_conversations[admin_id]
    msg_id = convo['msg_id']

    try:
        target_user_id = int(text)
        # On success, now we pop the conversation.
        admin_conversations.pop(admin_id, None)
        
        _safe_edit(admin_id, msg_id, escape_markdown("‚è≥ ÿØÿ± ÿ≠ÿßŸÑ ÿ¨ÿ≥ÿ™ÿ¨Ÿà..."))

        user_uuids = db.uuids(target_user_id)
        if not user_uuids:
            kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà", callback_data="admin:search_menu"))
            _safe_edit(admin_id, msg_id, escape_markdown(f"‚ùå Ÿá€å⁄Ü ÿß⁄©ÿßŸÜÿ™€å ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá {target_user_id} €åÿßŸÅÿ™ ŸÜÿ¥ÿØ."), reply_markup=kb)
            # Put conversation back to allow another try
            admin_conversations[admin_id] = {'action_type': 'search_by_tid', 'msg_id': msg_id}
            bot.register_next_step_handler_by_chat_id(admin_id, _find_user_by_telegram_id)
            return

        # (The rest of the success logic for finding one or multiple users remains the same)
        if len(user_uuids) == 1:
            uuid_str = user_uuids[0]['uuid']
            info = combined_handler.get_combined_user_info(uuid_str)
            if info:
                db_user = db.user(target_user_id)
                panel = 'hiddify' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'marzban'
                text = fmt_admin_user_summary(info, db_user)
                kb = menu.admin_user_interactive_management(uuid_str, info.get('is_active', False), panel, back_callback="admin:search_menu")
                _safe_edit(admin_id, msg_id, text, reply_markup=kb)
            else:
                _safe_edit(admin_id, msg_id, escape_markdown("‚ùå ÿÆÿ∑ÿß ÿØÿ± ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿßÿ≤ ŸæŸÜŸÑ."), reply_markup=menu.admin_search_menu())
            return

        kb = types.InlineKeyboardMarkup()
        db_user = db.user(target_user_id)
        first_name = escape_markdown(db_user.get('first_name', f"⁄©ÿßÿ±ÿ®ÿ± {target_user_id}"))

        for row in user_uuids:
            button_text = f"üë§ {row.get('name', 'ÿß⁄©ÿßŸÜÿ™ ŸÜÿßÿ¥ŸÜÿßÿ≥')}"
            info = combined_handler.get_combined_user_info(row['uuid'])
            if info:
                panel = 'hiddify' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'marzban'
                panel_short = 'h' if panel == 'hiddify' else 'm'
                kb.add(types.InlineKeyboardButton(button_text, callback_data=f"admin:us:{panel_short}:{row['uuid']}:search"))

        kb.add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿ¨ÿ≥ÿ™ÿ¨Ÿà", callback_data="admin:search_menu"))
        prompt = f"⁄ÜŸÜÿØ€åŸÜ ÿß⁄©ÿßŸÜÿ™ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± *{first_name}* €åÿßŸÅÿ™ ÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
        _safe_edit(admin_id, msg_id, escape_markdown(prompt), reply_markup=kb)


    except ValueError:
        # Only edit the message to show the error if it hasn't been shown before.
        if not convo.get('invalid_id_error_sent'):
            kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ÿ¨ÿ≥ÿ™ÿ¨Ÿà", callback_data="admin:search_menu"))
            _safe_edit(admin_id, msg_id, escape_markdown("‚ùå ÿ¥ŸÜÿßÿ≥Ÿá Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿπÿØÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ."), reply_markup=kb)
            # Set the flag in the conversation to prevent re-editing.
            admin_conversations[admin_id]['invalid_id_error_sent'] = True
        
        # Re-register the handler to wait for the next input.
        bot.register_next_step_handler_by_chat_id(admin_id, _find_user_by_telegram_id)
        return


def handle_select_panel_for_edit(call, params):
    edit_type, identifier = params[0], params[1]
    context = "search" if len(params) > 2 and params[2] == 'search' else None
    context_suffix = f":{context}" if context else ""

    edit_type_map = {"agb": "ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≠ÿ¨ŸÖ", "ady": "ÿßŸÅÿ≤ŸàÿØŸÜ ÿ±Ÿàÿ≤"}
    edit_type_name = edit_type_map.get(edit_type, edit_type)

    prompt = f"‚öôÔ∏è ŸÑÿ∑ŸÅÿßŸã ŸæŸÜŸÑ€å ⁄©Ÿá ŸÖ€å‚ÄåÿÆŸàÿßŸá€åÿØ ¬´{edit_type_name}¬ª ÿ®Ÿá ÿ¢ŸÜ ÿßÿ∂ÿßŸÅŸá ÿ¥ŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
    
    kb = types.InlineKeyboardMarkup(row_width=2)
    
    btn_h = types.InlineKeyboardButton("ÿ¢ŸÑŸÖÿßŸÜ üá©üá™", callback_data=f"admin:ae:{edit_type}:hiddify:{identifier}{context_suffix}")
    btn_m = types.InlineKeyboardButton("ŸÅÿ±ÿßŸÜÿ≥Ÿá üá´üá∑", callback_data=f"admin:ae:{edit_type}:marzban:{identifier}{context_suffix}")
    
    kb.add(btn_h, btn_m)
    kb.add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=f"admin:edt:{identifier}{context_suffix}"))
    
    _safe_edit(call.from_user.id, call.message.message_id, escape_markdown(prompt), reply_markup=kb)

def handle_purge_user_convo(call, params):
    uid, msg_id = call.from_user.id, call.message.message_id
    prompt = escape_markdown("‚ö†Ô∏è ÿ™Ÿàÿ¨Ÿá: ÿß€åŸÜ ÿπŸÖŸÑ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®Ÿá ÿ∑Ÿàÿ± ⁄©ÿßŸÖŸÑ ÿßÿ≤ ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ ÿ≠ÿ∞ŸÅ ŸÖ€å‚Äå⁄©ŸÜÿØ Ÿà ÿ∫€åÿ±ŸÇÿßÿ®ŸÑ ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿßÿ≥ÿ™.\n\nŸÑÿ∑ŸÅÿßŸã ÿ¥ŸÜÿßÿ≥Ÿá ÿπÿØÿØ€å (ID) ⁄©ÿßÿ±ÿ®ÿ± ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿ®ÿ±ÿß€å Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ⁄©ÿßŸÖŸÑ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:")

    admin_conversations[uid] = {'action_type': 'purge_user', 'msg_id': msg_id}

    _safe_edit(uid, msg_id, prompt, reply_markup=menu.admin_cancel_action("admin:search_menu"))
    bot.register_next_step_handler_by_chat_id(uid, _confirm_and_purge_user)

def _confirm_and_purge_user(message: types.Message):
    admin_id, text = message.from_user.id, message.text.strip()
    bot.delete_message(admin_id, message.message_id)

    if admin_id not in admin_conversations: return

    convo = admin_conversations.pop(admin_id, {})
    msg_id = convo['msg_id']

    try:
        target_user_id = int(text)
    except ValueError:
        _safe_edit(admin_id, msg_id, escape_markdown("‚ùå ÿ¥ŸÜÿßÿ≥Ÿá Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™. ÿπŸÖŸÑ€åÿßÿ™ ŸÑÿ∫Ÿà ÿ¥ÿØ."), reply_markup=menu.admin_search_menu())
        return

    _safe_edit(admin_id, msg_id, escape_markdown("‚è≥ ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ⁄©ÿßŸÖŸÑ ⁄©ÿßÿ±ÿ®ÿ±..."))

    if db.purge_user_by_telegram_id(target_user_id):
        success_msg = f"‚úÖ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá {target_user_id} ÿ®Ÿá ÿ∑Ÿàÿ± ⁄©ÿßŸÖŸÑ ÿßÿ≤ ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ÿ¥ÿØ. ÿß⁄©ŸÜŸàŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿØŸàÿ®ÿßÿ±Ÿá ÿ´ÿ®ÿ™ ŸÜÿßŸÖ ⁄©ŸÜÿØ."
        _safe_edit(admin_id, msg_id, escape_markdown(success_msg), reply_markup=menu.admin_search_menu())
    else:
        error_msg = f"‚ùå ⁄©ÿßÿ±ÿ®ÿ±€å ÿ®ÿß ÿ¥ŸÜÿßÿ≥Ÿá {target_user_id} ÿØÿ± ÿ¨ÿØŸàŸÑ ÿßÿµŸÑ€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ."
        _safe_edit(admin_id, msg_id, escape_markdown(error_msg), reply_markup=menu.admin_search_menu())


def handle_delete_devices_confirm(call, params):
    """
    Asks for confirmation before deleting devices and checks if there are any.
    """
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    uid, msg_id = call.from_user.id, call.message.message_id

    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß UUID ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    uuid_id_in_db = db.get_uuid_id_by_uuid(info['uuid'])
    if not uuid_id_in_db:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    device_count = db.count_user_agents(uuid_id_in_db)
    
    panel_short_for_back = 'h' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'm'
    context_suffix = f":{context}" if context else ""
    back_callback = f"admin:us:{panel_short_for_back}:{identifier}{context_suffix}"

    if device_count == 0:
        prompt = "‚ÑπÔ∏è Ÿá€å⁄Ü ÿØÿ≥ÿ™⁄ØÿßŸá€å ÿ®ÿ±ÿß€å ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá ÿßÿ≥ÿ™."
        kb = types.InlineKeyboardMarkup().add(types.InlineKeyboardButton("üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™", callback_data=back_callback))
        _safe_edit(uid, msg_id, escape_markdown(prompt), reply_markup=kb)
        return

    prompt = f"‚ö†Ô∏è ÿ¢€åÿß ÿßÿ≤ ÿ≠ÿ∞ŸÅ *{device_count}* ÿØÿ≥ÿ™⁄ØÿßŸá ÿ´ÿ®ÿ™ ÿ¥ÿØŸá ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± ¬´{escape_markdown(info.get('name', ''))}¬ª ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿØÿßÿ±€åÿØÿü"
    
    kb = types.InlineKeyboardMarkup(row_width=2)
    confirm_callback = f"admin:del_devs_exec:{identifier}{context_suffix}"
    kb.add(
        types.InlineKeyboardButton("‚úÖ ÿ®ŸÑŸáÿå ÿ≠ÿ∞ŸÅ ⁄©ŸÜ", callback_data=confirm_callback),
        types.InlineKeyboardButton("‚ùå ÿßŸÜÿµÿ±ÿßŸÅ", callback_data=back_callback)
    )
    _safe_edit(uid, msg_id, prompt, reply_markup=kb)


def handle_delete_devices_action(call, params):
    """Deletes all recorded devices for a user and confirms."""
    # Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß ÿ®Ÿá ÿØÿ±ÿ≥ÿ™€å ÿÆŸàÿßŸÜÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    uid, msg_id = call.from_user.id, call.message.message_id

    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß UUID ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    uuid_id_in_db = db.get_uuid_id_by_uuid(info['uuid'])
    if not uuid_id_in_db:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return

    deleted_count = db.delete_user_agents_by_uuid_id(uuid_id_in_db)
    
    bot.answer_callback_query(call.id, f"‚úÖ {deleted_count} ÿØÿ≥ÿ™⁄ØÿßŸá ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ≠ÿ∞ŸÅ ÿ¥ÿØ.", show_alert=True)
    
    # --- ‚ú® ÿ¥ÿ±Ÿàÿπ ÿßÿµŸÑÿßÿ≠ ÿßÿµŸÑ€å ---
    # ÿØÿ± ÿß€åŸÜ ÿ®ÿÆÿ¥ÿå Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤ ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿµÿ≠€åÿ≠ ÿ®Ÿá ÿµŸÅÿ≠Ÿá ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ÿßÿ≤ÿ≥ÿßÿ≤€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    
    # 1. ŸÜŸàÿπ ŸæŸÜŸÑ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ÿ±ÿß€å ÿ≥ÿßÿÆÿ™ ÿØ⁄©ŸÖŸá‚ÄåŸáÿß ÿ™ÿ¥ÿÆ€åÿµ ŸÖ€å‚ÄåÿØŸá€åŸÖ
    panel_short = 'h' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'm'
    
    # 2. ŸÑ€åÿ≥ÿ™ Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å ÿ¨ÿØ€åÿØ ÿ±ÿß ŸÖÿ∑ÿßÿ®ŸÇ ÿ®ÿß ŸÅÿ±ŸÖÿ™ ÿ™ÿßÿ®ÿπ `handle_show_user_summary` ŸÖ€å‚Äåÿ≥ÿßÿ≤€åŸÖ
    new_params_for_summary = [panel_short, identifier]
    if context:
        new_params_for_summary.append(context)
        
    # 3. ÿµŸÅÿ≠Ÿá ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ÿß Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß€å ÿµÿ≠€åÿ≠ ÿØŸàÿ®ÿßÿ±Ÿá ŸÅÿ±ÿßÿÆŸàÿßŸÜ€å Ÿà ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    handle_show_user_summary(call, new_params_for_summary)
    # --- ‚ú® Ÿæÿß€åÿßŸÜ ÿßÿµŸÑÿßÿ≠ ÿßÿµŸÑ€å ---

def _check_and_apply_loyalty_reward(user_telegram_id: int, uuid_id: int, user_uuid: str, user_name: str):
    """
    Ÿàÿ∂ÿπ€åÿ™ ŸàŸÅÿßÿØÿßÿ±€å ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ÿ±ÿØŸá Ÿà ÿØÿ± ÿµŸàÿ±ÿ™ Ÿàÿßÿ¨ÿØ ÿ¥ÿ±ÿß€åÿ∑ ÿ®ŸàÿØŸÜÿå ŸæÿßÿØÿßÿ¥ ÿ±ÿß ÿßÿπŸÖÿßŸÑ ŸÖ€å‚Äå⁄©ŸÜÿØ.
    """
    if not LOYALTY_REWARDS:
        return

    try:
        # ÿ™ÿπÿØÿßÿØ ⁄©ŸÑ Ÿæÿ±ÿØÿßÿÆÿ™‚ÄåŸáÿß€å ÿ´ÿ®ÿ™‚Äåÿ¥ÿØŸá ÿ®ÿ±ÿß€å ÿß€åŸÜ ÿß⁄©ÿßŸÜÿ™ ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸÖÿßÿ±€åŸÖ
        payment_count = len(db.get_user_payment_history(uuid_id))
        
        # ÿ®ÿ±ÿ±ÿ≥€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ ÿ¢€åÿß ÿ¥ŸÖÿßÿ±Ÿá ÿ™ŸÖÿØ€åÿØ ŸÅÿπŸÑ€åÿå ÿØÿ± ŸÑ€åÿ≥ÿ™ ŸæÿßÿØÿßÿ¥‚ÄåŸáÿß€å ŸÖÿß Ÿàÿ¨ŸàÿØ ÿØÿßÿ±ÿØ €åÿß ŸÜŸá
        reward = LOYALTY_REWARDS.get(payment_count)

        if reward:
            add_gb = reward.get("gb", 0)
            add_days = reward.get("days", 0)

            # ÿßÿπŸÖÿßŸÑ ÿ™ÿ∫€å€åÿ±ÿßÿ™ (ÿßŸÅÿ≤ŸàÿØŸÜ ÿ≠ÿ¨ŸÖ Ÿà ÿ±Ÿàÿ≤) ÿ®Ÿá ÿ™ŸÖÿßŸÖ ŸæŸÜŸÑ‚ÄåŸáÿß€å ⁄©ÿßÿ±ÿ®ÿ±
            if combined_handler.modify_user_on_all_panels(user_uuid, add_gb=add_gb, add_days=add_days):
                # ÿ≥ÿßÿÆÿ™ Ÿæ€åÿßŸÖ ÿ™ÿ®ÿ±€å⁄© ÿ®ÿ±ÿß€å ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ±
                notification_text = (
                    f"üéâ *ŸáÿØ€åŸá ŸàŸÅÿßÿØÿßÿ±€å* üéâ\n\n"
                    f"ÿßÿ≤ ŸáŸÖÿ±ÿßŸá€å ÿµŸÖ€åŸÖÿßŸÜŸá ÿ¥ŸÖÿß ÿ≥Ÿæÿßÿ≥⁄Øÿ≤ÿßÿ±€åŸÖ\\! ÿ®Ÿá ŸÖŸÜÿßÿ≥ÿ®ÿ™ *{payment_count}* ÿßŸÖ€åŸÜ ÿ™ŸÖÿØ€åÿØ ÿ≥ÿ±Ÿà€åÿ≥ÿå ŸáÿØ€åŸá ÿ≤€åÿ± ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ŸÅÿπÿßŸÑ ÿ¥ÿØ:\n\n"
                    f"üéÅ `{add_gb} GB` ÿ≠ÿ¨ŸÖ Ÿà `{add_days}` ÿ±Ÿàÿ≤ ÿßÿπÿ™ÿ®ÿßÿ± ÿßÿ∂ÿßŸÅ€å\n\n"
                    f"ÿß€åŸÜ ŸáÿØ€åŸá ÿ®Ÿá ÿµŸàÿ±ÿ™ ÿÆŸàÿØ⁄©ÿßÿ± ÿ®Ÿá ÿß⁄©ÿßŸÜÿ™ ÿ¥ŸÖÿß ÿßÿ∂ÿßŸÅŸá ÿ¥ÿØ\\. ÿßŸÖ€åÿØŸàÿßÿ±€åŸÖ ÿßÿ≤ ÿ¢ŸÜ ŸÑÿ∞ÿ™ ÿ®ÿ®ÿ±€åÿØ\\."
                )
                _notify_user(user_telegram_id, notification_text)
                logger.info(f"Applied loyalty reward to user_id {user_telegram_id} for {payment_count} payments.")

    except Exception as e:
        logger.error(f"Error checking/applying loyalty reward for user_id {user_telegram_id}: {e}", exc_info=True)


def _check_and_apply_referral_reward(user_telegram_id: int):
    """ÿ®ÿ±ÿ±ÿ≥€å Ÿà ÿßÿπŸÖÿßŸÑ ŸæÿßÿØÿßÿ¥ ŸÖÿπÿ±ŸÅ€å Ÿæÿ≥ ÿßÿ≤ ÿßŸàŸÑ€åŸÜ Ÿæÿ±ÿØÿßÿÆÿ™."""
    try:
        referrer_info = db.get_referrer_info(user_telegram_id)
        # ŸæÿßÿØÿßÿ¥ ŸÅŸÇÿ∑ ÿØÿ± ÿµŸàÿ±ÿ™€å ÿßÿπŸÖÿßŸÑ ŸÖ€å‚Äåÿ¥ŸàÿØ ⁄©Ÿá ⁄©ÿßÿ±ÿ®ÿ± ŸÖÿπÿ±ŸÅ ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØ Ÿà ŸÇÿ®ŸÑÿßŸã ŸæÿßÿØÿßÿ¥ ŸÜ⁄Øÿ±ŸÅÿ™Ÿá ÿ®ÿßÿ¥ÿØ
        if referrer_info and not referrer_info.get('referral_reward_applied'):
            referrer_id = referrer_info['referred_by_user_id']

            # Ÿæ€åÿØÿß ⁄©ÿ±ÿØŸÜ UUID Ÿáÿß€å Ÿáÿ± ÿØŸà ⁄©ÿßÿ±ÿ®ÿ±
            new_user_uuid = db.uuids(user_telegram_id)[0]['uuid']
            referrer_uuid = db.uuids(referrer_id)[0]['uuid']

            # ÿßÿπŸÖÿßŸÑ ŸæÿßÿØÿßÿ¥ ÿ®Ÿá Ÿáÿ± ÿØŸà
            combined_handler.modify_user_on_all_panels(new_user_uuid, add_gb=REFERRAL_REWARD_GB, add_days=REFERRAL_REWARD_DAYS)
            combined_handler.modify_user_on_all_panels(referrer_uuid, add_gb=REFERRAL_REWARD_GB, add_days=REFERRAL_REWARD_DAYS)

            # ÿ´ÿ®ÿ™ ÿßÿπŸÖÿßŸÑ ŸæÿßÿØÿßÿ¥ ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥
            db.mark_referral_reward_as_applied(user_telegram_id)

            # ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿ™ÿ®ÿ±€å⁄©
            new_user_name = escape_markdown(db.user(user_telegram_id).get('first_name', ''))
            referrer_name = escape_markdown(db.user(referrer_id).get('first_name', ''))

            _notify_user(user_telegram_id, f"üéÅ ŸáÿØ€åŸá ÿßŸàŸÑ€åŸÜ ÿÆÿ±€åÿØ ÿ¥ŸÖÿß ({REFERRAL_REWARD_GB}GB) ÿ®Ÿá ÿØŸÑ€åŸÑ ŸÖÿπÿ±ŸÅ€å ÿ™Ÿàÿ≥ÿ∑ *{referrer_name}* ŸÅÿπÿßŸÑ ÿ¥ÿØ\\!")
            _notify_user(referrer_id, f"üéâ ÿ™ÿ®ÿ±€å⁄©\\! ⁄©ÿßÿ±ÿ®ÿ± *{new_user_name}* ÿßŸàŸÑ€åŸÜ ÿÆÿ±€åÿØ ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ¨ÿßŸÖ ÿØÿßÿØ Ÿà ŸáÿØ€åŸá ŸÖÿπÿ±ŸÅ€å ({REFERRAL_REWARD_GB}GB) ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ŸÅÿπÿßŸÑ ÿ¥ÿØ\\.")

            logger.info(f"Referral reward applied for user {user_telegram_id} and referrer {referrer_id}.")

    except Exception as e:
        logger.error(f"Error applying referral reward for user {user_telegram_id}: {e}", exc_info=True)


def handle_reset_transfer_cooldown(call, params):
    """ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ≤ŸÖÿßŸÜ€å ÿßŸÜÿ™ŸÇÿßŸÑ ÿ™ÿ±ÿßŸÅ€å⁄© ÿ±ÿß ÿ®ÿ±ÿß€å €å⁄© ⁄©ÿßÿ±ÿ®ÿ± ÿ±€åÿ≥ÿ™ ŸÖ€å‚Äå⁄©ŸÜÿØ."""
    identifier = params[0]
    context = "search" if len(params) > 1 and params[1] == 'search' else None
    
    info = combined_handler.get_combined_user_info(identifier)
    if not info or not info.get('uuid'):
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± €åÿßŸÅÿ™ ŸÜÿ¥ÿØ €åÿß UUID ŸÜÿØÿßÿ±ÿØ.", show_alert=True)
        return

    uuid_id_to_reset = db.get_uuid_id_by_uuid(info['uuid'])
    if not uuid_id_to_reset:
        bot.answer_callback_query(call.id, "‚ùå ⁄©ÿßÿ±ÿ®ÿ± ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ±ÿ®ÿßÿ™ ÿ®ÿ±ÿß€å ÿ±€åÿ≥ÿ™ ⁄©ÿ±ÿØŸÜ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.", show_alert=True)
        return
        
    deleted_count = db.delete_transfer_history(uuid_id_to_reset)
    
    if deleted_count > 0:
        bot.answer_callback_query(call.id, f"‚úÖ ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿßŸÜÿ™ŸÇÿßŸÑ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± ¬´{info.get('name', '')}¬ª ÿ±€åÿ≥ÿ™ ÿ¥ÿØ.", show_alert=True)
    else:
        bot.answer_callback_query(call.id, "‚ÑπÔ∏è ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± ÿ™ÿßÿ±€åÿÆ⁄ÜŸá ÿßŸÜÿ™ŸÇÿßŸÑ€å ÿ®ÿ±ÿß€å ÿ±€åÿ≥ÿ™ ⁄©ÿ±ÿØŸÜ ŸÜÿØÿßÿ¥ÿ™.", show_alert=True)

    # --- ‚úÖ ÿ®ÿÆÿ¥ ÿßÿµŸÑÿßÿ≠ ÿ¥ÿØŸá ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿµÿ≠€åÿ≠ ---
    # Ÿæÿßÿ±ÿßŸÖÿ™ÿ±Ÿáÿß ÿ±ÿß ÿ®ÿ±ÿß€å ŸÅÿ±ÿßÿÆŸàÿßŸÜ€å ÿµÿ≠€åÿ≠ ÿ™ÿßÿ®ÿπ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßÿ±ÿ®ÿ±ÿå ÿ®ÿßÿ≤ÿ≥ÿßÿ≤€å ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    panel_short = 'h' if any(p.get('type') == 'hiddify' for p in info.get('breakdown', {}).values()) else 'm'
    new_params_for_summary = [panel_short, identifier]
    if context:
        new_params_for_summary.append(context)
        
    handle_show_user_summary(call, new_params_for_summary)